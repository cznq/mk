{
  "_args": [
    [
      {
        "raw": "vuex-saga@^0.1.3",
        "scope": null,
        "escapedName": "vuex-saga",
        "name": "vuex-saga",
        "rawSpec": "^0.1.3",
        "spec": ">=0.1.3 <0.2.0",
        "type": "range"
      },
      "C:\\Users\\Administrator\\Desktop\\mk-elm"
    ]
  ],
  "_cnpm_publish_time": 1491512912348,
  "_from": "vuex-saga@^0.1.3",
  "_hasShrinkwrap": false,
  "_id": "vuex-saga@0.1.3",
  "_location": "/vuex-saga",
  "_nodeVersion": "6.9.2",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/vuex-saga-0.1.3.tgz_1491512910441_0.7651787311770022"
  },
  "_npmUser": {
    "name": "bosnaufal",
    "email": "bosnaufalemail@gmail.com"
  },
  "_npmVersion": "3.10.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "vuex-saga@^0.1.3",
    "scope": null,
    "escapedName": "vuex-saga",
    "name": "vuex-saga",
    "rawSpec": "^0.1.3",
    "spec": ">=0.1.3 <0.2.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://npm.1024.team/vuex-saga/-/vuex-saga-0.1.3.tgz",
  "_shasum": "a9d679894ab572085779b3bc04d9731c74825a3c",
  "_shrinkwrap": null,
  "_spec": "vuex-saga@^0.1.3",
  "_where": "C:\\Users\\Administrator\\Desktop\\mk-elm",
  "author": {
    "name": "Naufal Rabbani",
    "email": "bosnaufalemail@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/BosNaufal/vuex-saga/issues"
  },
  "dependencies": {},
  "description": "Better Vuex Action To Simplify Your Async Flow Process And Code Testing",
  "devDependencies": {
    "babel-core": "^6.3.17",
    "babel-loader": "^6.2.0",
    "babel-plugin-transform-object-rest-spread": "^6.8.0",
    "babel-plugin-transform-regenerator": "^6.21.0",
    "babel-plugin-transform-runtime": "^6.3.13",
    "babel-polyfill": "^6.20.0",
    "babel-preset-es2015": "^6.3.13",
    "babel-runtime": "^5.8.34",
    "es6-promise": "^3.2.1",
    "webpack": "^1.14.0",
    "webpack-dev-server": "^1.14.0"
  },
  "directories": {},
  "dist": {
    "shasum": "a9d679894ab572085779b3bc04d9731c74825a3c",
    "size": 7292,
    "noattachment": false,
    "tarball": "http://npm.1024.team/vuex-saga/-/vuex-saga-0.1.3.tgz"
  },
  "gitHead": "3c7eb102422c52aeb204fc41e34eef27994646da",
  "homepage": "https://github.com/BosNaufal/vuex-saga#readme",
  "keywords": [
    "vue-js",
    "saga",
    "vuex-saga",
    "vuex-plugin",
    "vuex",
    "vuex-saga",
    "vue-plugin",
    "vue-test",
    "redux-saga",
    "vue-async",
    "generator-function",
    "generator",
    "async-flow",
    "async",
    "await",
    "vue-2"
  ],
  "license": "MIT",
  "main": "./dist/vuex-saga.js",
  "maintainers": [
    {
      "name": "bosnaufal",
      "email": "bosnaufalemail@gmail.com"
    }
  ],
  "name": "vuex-saga",
  "optionalDependencies": {},
  "publish_time": 1491512912348,
  "readme": "# Vuex Saga\n\nBetter Vuex Action To Simplify Your Async Flow Process And Code Testing. It's inspired by  [redux-saga](https://github.com/redux-saga/redux-saga) but it works differently. Vuex Saga just simplify the action for async and testing while redux-saga is being advance async flow control which can make some watchers.\n\n[DEMO](https://rawgit.com/BosNaufal/vuex-saga/master/index.html)\n\n## Installation\nYou can import [vuex-saga.js](./dist/vuex-saga.js) to your vue component file like [this](./examples/simple/main.js) and process it with your preprocessor.\n\nYou can install it via NPM\n```bash\nnpm install vuex-saga\n```\n\n## Dependencies\nYou need to install babel-polyfill and babel regenerator plugin and put it in the first line of your main entry file to make it works. You can check the example [here](./examples/simple/main.js).\n```bash\nnpm install babel-polyfill babel-plugin-transform-regenerator\n```\n\nAnd Don't forget to add the plugin to your [```.babelrc```](./.babelrc)\n```json\n{\n  \"plugins\": [\"transform-regenerator\"]\n}\n```\n\nAnd Install it as a [Vue Plugin](https://vuejs.org/v2/guide/plugins.html#Using-a-Plugin) like this.\n```javascript\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport VuexSaga from 'vuex-saga';\n\n// Make A Vuex Store\nVue.use(Vuex)\nconst store = new Vuex.Store({\n  modules: { /* Some Modules */ }\n})\n\n// Install it by pass your store to be an option argument (Since v0.1.0)\nVue.use(VuexSaga, { store: store })\n```\n\n\n## Why I Need This?\nProbably you don't need it. But in some cases you'll find a busy async process that you'll hard to organize with ordinary Promise function. For example:\n\n```javascript\nimport api from '../api'\n\n// Variable for saving the responses\nlet product, seller, statistic;\n\napi.fetchProduct()\n.then((res) => {\n  product = res\n  return api.fetchSeller(product.id)\n})\n.then((res) => {\n  seller = res\n  return api.statistic(product, seller)\n})\n.then((res) => {\n  statistic = res\n  return api.needStatisticProductAndSeller(statistic, product, seller)\n})\n```\n\nOr you can skip the ```let``` declaration\n\n```javascript\n// source: https://codepen.io/aurelien-bottazini/pen/VPQLBp?editors=0011\n\nconst api = {\n  fetchProduct() { return Promise.resolve({ id: 'productId'}) },\n  fetchSeller(id) { return Promise.resolve('seller') },\n  statistic(product, seller) { return  Promise.resolve('stats') },\n  needStatisticProductAndSeller(statistic, product, seller) {\n    return Promise.resolve('finalResult')\n  },\n};\n\napi.fetchProduct()\n.then((product) => api.fetchSeller(product.id)\n      .then((seller) => ({ product, seller })))\n.then(({ product, seller }) => api.statistic(product, seller)\n      .then((statistic) => ({ product, seller, statistic })))\n.then(({ product, seller, statistic }) =>  api.needStatisticProductAndSeller(statistic, product, seller))\n.then(console.log);\n```\n\nThe solution is pretty simple, You can use [async/await](https://ponyfoo.com/articles/understanding-javascript-async-await)\n\n```javascript\n// source: https://forum.vuejs.org/t/let-s-write-better-vuex-action-with-vuex-saga/5527/2\n\nimport api from '../api'\n\nasync function do () {\n  const product = await api.fetchProduct()\n  const seller = await api.fetchSeller(product.id)\n  const statistic = await api.statistic(product, seller)\n  const res = await api.needStatisticProductAndSeller(statistic , product, seller)\n  // ...\n}\n```\nYou could use aync/await which are compatible with Promises. You can easily do that with Babel or natively in Chrome and Opera. Firefox and Edge support is coming in their next versions (FX 52, Edge 15). But another point that you should notice is **\"How can you test it Effortlessly?\"**. For now, I have no idea to test async/await function.\n\n\n## How About Vuex Saga?\nAccording to our cases above, we can simplify that code with [```Generator Function```](). It will make our async code looks like synchronous code. Take a look:\n```javascript\nimport api from '../api'\n\nfunction *fetchFlow() {\n  let product = yield call(api.fetchProduct)\n  let seller = yield call(api.fetchSeller, { product })\n  let statistic = yield call(api.statistic, { product, seller })\n  let lastFetch = yield call(api.needStatisticProductAndSeller, { statistic, product, seller })\n  return lastFetch\n}\n```\n\nPretty simple right? It works like async/await function. But You'll get a better testing process although your testing a deep promise function. Take a peek:\n```javascript\nimport { call } from 'vuex-saga'\nimport api from '../api'\nimport { fetchFlow } from '../actions';\nimport assert from 'assert';\n\ndescribe('fetchFlow()', function () {\n\n  it('Should Run The Flow Correctly ', function () {\n    let process = fetchFlow()\n\n    let fakeRespon = {}\n\n    assert.deepEqual(process.next().value, call(api.fetchProduct))\n    assert.deepEqual(process.next(fakeRespon).value, call(api.fetchSeller, { fakeRespon }))\n    assert.deepEqual(process.next(fakeRespon).value, call(api.statistic, { fakeRespon }))\n    assert.deepEqual(process.next(fakeRespon).value, call(api.needStatisticProductAndSeller, { fakeRespon }))\n  });\n\n});\n```\n\nWait? Are you sure it's a valid testing process? I'm not sure yet. But It works. You don't need to mock the promises, You don't need run the real fetch function in the browser, It just works. Let me tell you how ```call()``` function works.\n\n```call()``` function is just an ordinary function that return a plain object contains our real function. So, the generator only pass the **plain object** while the runner excute the function from the object. Since we don't use the runner, we can test our code like the example above, Just need to deep compare two object.\n\n\n## How About Nested Sagas?\nIt's just the same, you can wrap it with ```call()``` function.\n```javascript\nimport { call } from 'vuex-saga'\nimport api from '../api'\n\nfunction *nestedGenFunc() {\n  yield call(delay, 1000)\n  return 1000\n}\n\nfunction *fetchFlow() {\n  let nested = yield call(nestedGenFunc)\n}\n```\n\n\n## Is it take care some parallel async process?\nYes, it should. Just wrap it within an array! Check it out.\n\n```javascript\nimport { call } from 'vuex-saga'\nimport api from '../api'\n\nfunction *fetchFlow() {\n  let [product, other] = yield [call(api.fetchProduct), call(api.otherApis)]\n}\n```\n\nThe limitation is, you can't run nested generator function in parallel but you can still run some promises or ordinary function (to fetch data or something) in parallel.\n\n\n## How to bind the saga (generator function) to run?\nVuex Saga has a method named ```sagaRun()``` which will bind the saga to run. You simple import it, but the recommended way is bind it from the component. We have a helper methods to do it.\n\n```html\n<template>\n  <div>\n    <h1>Hello World</h1>\n  </div>\n</template>\n\n<script>\n\n  export default {\n\n    created() {\n      this.$run(\"nameOfSaga\", { argument })\n      .then((res) => {\n        // when saga has finished\n      })\n    }\n\n  }\n\n</script>\n```\n\nThe ```$run``` method is similiar with  ```store.dispatch``` method. But it can run the generator function. At the last, it will pass a returned value from the generator function (saga). Do you think it's not comfortable to write? we also have ```mapSagas()``` method that will mapping our sagas to the local methods just like the ```Vuex.mapActions()``` do.\n\n```html\n<template>\n  <div>\n    <h1>Hello World</h1>\n  </div>\n</template>\n\n<script>\n\n  import { mapSagas } from 'vuex-saga';\n\n  export default {\n\n    methods: {\n      ...mapSagas({\n        test: \"nameOfSaga\"\n      })\n    },\n\n    created() {\n      this.test({ argument })\n      .then((res) => {\n        // when saga has finished\n      })\n    }\n\n  }\n\n</script>\n```\n\n\n## How if I want to change the state? Should I use ```store.commit()```?\nYou can still use ```store.commit()``` but it will hard to test. Instead, we have a helper method called ```put()``` function. It's just the same with ```call()``` function but it's used to run some mutation.\n\n```javascript\nimport Vuex from 'vuex'\nimport Vue from 'vue';\nimport { call, put, delay } from 'vuex-saga'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state, payload) {\n      state.count += payload\n    }\n  },\n  actions: {\n    *incrementAsync(store, payload) {\n      yield call(delay,1000)\n      yield put(\"increment\", 2)\n\n      yield call(delay,700)\n      yield put(\"increment\", 10)\n      return store.count\n    }\n  }\n})\n\nexport default store\n```\n\nHow do I test it? Just the same way with the ```call()``` testing.\n\n```javascript\n\nimport { call, put, delay } from 'vuex-saga'\nimport api from '../api'\nimport { incrementAsync } from '../actions';\nimport assert from 'assert';\n\ndescribe('incrementAsync()', function () {\n  it('Should Run The Flow Correctly ', function () {\n    let process = incrementAsync()\n\n    assert.deepEqual(process.next().value, call(delay,1000))\n    assert.deepEqual(process.next().value, put(\"increment\", 2))\n    assert.deepEqual(process.next().value, call(delay,700))\n    assert.deepEqual(process.next().value, put(\"increment\", 10))\n  });\n\n});\n```\n\nSo now, you can test the flow and the fetch process separately. It will make your code easy to test. No more reason to not doing a test.\n\n## Limitation\nThere's a limitation. But it wil not make us harder to write. The limitation is, We Can't run nested generator function in parallel\n\n```javascript\nimport api from '../api'\n\nfunction *nestedGenFunc() {\n  yield call(delay, 1000)\n  return 1000\n}\n\nfunction *fetchFlow() {\n  let [a, b] = yield [call(nestedGenFunc), call(nestedGenFunc)] // Will throw error\n\n  // Instead, it will be run\n  let [product, other] = yield [call(api.fetch), call(api.fetcOther)]\n  let a = yield call(nestedGenFunc) // It will run too\n  let b = yield call(nestedGenFunc) // it will run too\n}\n```\n\n\n## API\n| Method | Format | Deskripsi |\n| :--- | :--- | :--- |\n| ```*saga()``` | passed arguments ```*saga(store, payload)``` | It's not a method form ```vuex-saga```. I just want you to know how the saga looks like. It recieve a ```store``` object and ```payload``` object. We can use it for logic bussiness within our saga. We should notice the (```*```) star symbol in the function name. It indicate that our function is a generator function |\n| ```delay()``` | ```delay(number)``` | It's just a simple method to delay some function inside the saga. Maybe, It will not used cause I made it just for making a fake async proccess |\n| ```call()``` | ```call(func, obj)``` | It's used to call some function. For best practice you should wrap your function to be a promise. The second arguments is single object—cause vuex action has only one argument for data payload—which will passed to the our sagas, You can access it from the saga. |\n| ```put()``` | ```put(string, obj)``` | It's Used to bind some vuex mutation. The behaviour is same with ```store.commit()``` method. The first Argument is the mutation name, and the second is the data payload which will be passed to the mutation |\n| ```vm.$run()``` | ```vm.$run(string, obj)``` | It's a method to run the sagas. the behaviour is similiar with ```store.dispatch()``` method. The first argument is action name, and the second argument is data payload. This method only run in the component instance. It always return a promise in the end of saga process |\n| ```mapSagas()``` | ```mapSagas(obj)``` | It's a method to mapping the sagas to be a local methods of component. the behaviour is similiar with ```Vuex.mapActions()``` method. It will return an object. You can check the example above about how to use it or you can check the ```Vuex.mapAction()``` method documentation |\n\n## Credits\n- [Redux Saga](redux-saga.github.io/redux-saga/)\n- [gen-run](https://github.com/creationix/gen-run)\n- [http://www.2ality.com/2015/03/es6-generators.html](http://www.2ality.com/2015/03/es6-generators.html)\n- [https://davidwalsh.name/es6-generators](https://davidwalsh.name/es6-generators)\n- [http://thejsguy.com/2016/10/15/a-practical-introduction-to-es6-generator-functions.html](http://thejsguy.com/2016/10/15/a-practical-introduction-to-es6-generator-functions.html)\n- [http://www.2ality.com/2015/03/no-promises.html](http://www.2ality.com/2015/03/no-promises.html)\n- [https://forum.vuejs.org/t/let-s-write-better-vuex-action-with-vuex-saga/5527/2](https://forum.vuejs.org/t/let-s-write-better-vuex-action-with-vuex-saga/5527/2)\n- [Let’s Write Better Vuex Action With Vuex Saga | Medium](https://medium.com/bosnaufal/lets-write-better-vuex-action-with-vuex-saga-956d69576957#.o1wzrunde)\n\n\n## Thank You for Making this useful~\n\n\n## Let's talk about some projects with me\nJust Contact Me At:\n- Email: [bosnaufalemail@gmail.com](mailto:bosnaufalemail@gmail.com)\n- Skype Id: bosnaufal254\n- twitter: [@BosNaufal](https://twitter.com/BosNaufal)\n\n\n## License\n[MIT](http://opensource.org/licenses/MIT)\nCopyright (c) Naufal Rabbani\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/BosNaufal/vuex-saga.git"
  },
  "scripts": {
    "build": "webpack --config ./webpack/webpack-prod.config.js -p",
    "bundle": "webpack --config ./webpack/webpack-bundle.config.js -p",
    "dev": "webpack-dev-server --config ./webpack/webpack.config.js --inline --hot",
    "test": "karma start karma.conf.js"
  },
  "version": "0.1.3"
}
