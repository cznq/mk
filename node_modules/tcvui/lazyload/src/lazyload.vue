

<script>


import { on, off } from 'tcvui/utils/event';
import scrollParent from 'tcvui/utils/scrollParent';
import debounce from 'tcvui/utils/debounce';
import throttle from 'tcvui/utils/throttle';
import {windowHeight,windowWidth} from 'tcvui/utils/dom';
const LISTEN_FLAG = 'data-lazyload-listened';
const listeners = [];

let pending = [];

let delayType;
let finalLazyLoadHandler = null;

export default {
 name: 'TcLazyLoad',
 props:{
   once:{
      default: false,
      type:Boolean
   },
   height:{
      default: 0,
      type:Number
   },
   offset:{
      default: 0,
      type:Number
   },
   overflow:{
     default: false,
      type:Boolean
   },
   resize:{
     default: false,
      type:Boolean
   },
   scroll:{
     default: true,
      type:Boolean
   },
   children:{
      type:Node
   },
   throttle:{
     type:Number
   },
   debounce:{
     type:Number
   },
   placeholder:{
     
   }
  

 },
 
 beforeMount(){
   this.visible = false;
 },
 mounted (){
  var self = this;
if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production') {
      

      if (this.wheel) { // eslint-disable-line
        console.warn('[lazyload] Props `wheel` is not supported anymore, try set `overflow` for lazy loading in overflow containers.');
      }

      // Warn the user if placeholder and height is not specified and the rendered height is 0
      if (!this.placeholder && this.height === undefined && this.$el.offsetHeight === 0) {
        console.warn('[lazyload] Please add `height` props to <TCLazyLoad> for better performance.');
      }
    }

    // It's unlikely to change delay type on the fly, this is mainly
    // designed for tests
    let needResetFinalLazyLoadHandler = false;
    if (this.debounce !== undefined && delayType === 'throttle') {
      console.warn('[lazyload] Previous delay function is `throttle`, now switching to `debounce`, try setting them unanimously');
      needResetFinalLazyLoadHandler = true;
    } else if (delayType === 'debounce' && this.debounce === undefined) {
      console.warn('[lazyload] Previous delay function is `debounce`, now switching to `throttle`, try setting them unanimously');
      needResetFinalLazyLoadHandler = true;
    }

    if (needResetFinalLazyLoadHandler) {
      off(window, 'scroll', finalLazyLoadHandler);
      off(window, 'resize', finalLazyLoadHandler);
      finalLazyLoadHandler = null;
    }

    if (!finalLazyLoadHandler) {
      if (this.debounce !== undefined) {
        finalLazyLoadHandler = debounce(self.lazyLoadHandler, typeof this.debounce === 'number' ?
                                                         this.debounce :
                                                         300);
        delayType = 'debounce';
      } else {
        finalLazyLoadHandler = throttle(self.lazyLoadHandler, typeof this.throttle === 'number' ?
                                                         this.throttle :
                                                         300);
        delayType = 'throttle';
      }
    }
    if (this.overflow) {

      const parent = scrollParent(this.$el);

      if (parent) {
        const listenerCount = 1 + (+parent.getAttribute(LISTEN_FLAG));
        if (listenerCount === 1) {
          parent.addEventListener('scroll', finalLazyLoadHandler);
        }
        parent.setAttribute(LISTEN_FLAG, listenerCount);
      }
    } else if (listeners.length === 0 || needResetFinalLazyLoadHandler) {

      const { scroll, resize } = this;

      if (scroll) {
   
        on(window, 'scroll', finalLazyLoadHandler);
      }

      if (resize) {
        on(window, 'resize', finalLazyLoadHandler);
      }
    }

    listeners.push(this);

    this.checkVisible(this);
 },
 beforeDestroy (){
    if (this.props.overflow) {
      const parent = scrollParent(this.$el);
      if (parent) {
        const listenerCount = (+parent.getAttribute(LISTEN_FLAG)) - 1;
        if (listenerCount === 0) {
          parent.removeEventListener('scroll', finalLazyLoadHandler);
          parent.removeAttribute(LISTEN_FLAG);
        } else {
          parent.setAttribute(LISTEN_FLAG, listenerCount);
        }
      }
    }

    const index = listeners.indexOf(this);
    if (index !== -1) {
      listeners.splice(index, 1);
    }

    if (listeners.length === 0) {
      off(window, 'resize', finalLazyLoadHandler);
      off(window, 'scroll', finalLazyLoadHandler);
    }
 },
 data () {
    return {
      
    }
  },
  watch:{
  },
  computed: {    
  },
  render (createElement){
    
    if(!!this.visible){
         return this.$slots.default[0]
    }else if(!!this.placeholder){
      console.log(this.placeholder)
         return <this.placeholder />
    }else{
      return (
           <div style={{ height:this.height+'px' }} class="lazyload-placeholder"></div>
        )
    }
  
  },
  methods: {
    /**
 * Check if `component` is visible in overflow container `parent`
 * @param  {node} component React component
 * @param  {node} parent    component's scroll parent
 * @return {bool}
 */
 checkOverflowVisible(component, parent) {
  const node = component.$el;
  const { top: parentTop, height: parentHeight } = parent.getBoundingClientRect();
  const windowInnerHeight = windowHeight();

  // calculate top and height of the intersection of the element's scrollParent and viewport
  const intersectionTop = Math.max(parentTop, 0); // intersection's top relative to viewport
  const intersectionHeight = Math.min(windowInnerHeight, parentTop + parentHeight) - intersectionTop; // height

  // check whether the element is visible in the intersection
  const { top, height } = node.getBoundingClientRect();
  const offsetTop = top - intersectionTop; // element's top relative to intersection

  const offsets = Array.isArray(component.offset) ?
                component.offset :
                [component.offset, component.offset]; // Be compatible with previous API

  return (offsetTop - offsets[0] <= intersectionHeight) &&
         (offsetTop + height + offsets[1] >= 0);
},
/**
 * Check if `component` is visible in document
 * @param  {node} component React component
 * @return {bool}
 */
checkNormalVisible(component) {  //判断是否在可视范围内
  const node = component.$el;

  const { top, height: elementHeight } = node.getBoundingClientRect();

  const windowInnerHeight = windowHeight();

  const offsets = Array.isArray(component.offset) ?
                component.offset :
                [component.offset, component.offset]; // Be compatible with previous API

  return (top - offsets[0] <= windowInnerHeight) &&
         (top + elementHeight + offsets[1] >= 0);
 },

 /**
 * Detect if element is visible in viewport, if so, set `visible` state to true.
 * If `once` prop is provided true, remove component as listener after checkVisible
 *
 * @param  {React} component   React component that respond to scroll and resize
 */
checkVisible(component) {
  const node = component.$el;
  if (!node) {
    return;
  }

  const parent = scrollParent(node);

  const isOverflow = parent !== node.ownerDocument &&
                     parent !== document &&
                     parent !== document.documentElement;

  const visible = isOverflow ?
                  this.checkOverflowVisible(component, parent) :
                  this.checkNormalVisible(component);
  if (visible) {
    // Avoid extra render if previously is visible, yeah I mean `render` call,
    // not actual DOM render
    if (!component.visible) {
      if (component.once) {
        pending.push(component);
      }

      component.visible = true;
      component.$forceUpdate();
    }
  } else if (!(component.once && component.visible)) {
    component.visible = false;
  }
},

 purgePending() {
   pending.forEach(component => {
    const index = listeners.indexOf(component);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
  });

  pending = [];
},


lazyLoadHandler ()  {
  for (let i = 0; i < listeners.length; ++i) {
    const listener = listeners[i];
    this.checkVisible(listener);
  }

  // Remove `once` component in listeners
  this.purgePending();
}




  }
}
</script>

<style>
  
</style>
