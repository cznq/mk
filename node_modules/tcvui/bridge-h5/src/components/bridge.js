'use strict';
const slice = [].slice;
 
function isFunction(value) { return typeof(value) == "function" }
function isObject(obj)     { return typeof(obj) == "object" }
function isPlainObject(obj) {
  return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype
}
function guid() {
    function _p8(s) {
        var p = (Math.random().toString(16) + "000000000").substr(2, 8);
        return s ? "-" + p.substr(0, 4) + "-" + p.substr(4, 4) : p;
    }
    return _p8() + _p8(true) + _p8(true) + _p8();
}
let isArray = Array.isArray ||
      function(object){ return object instanceof Array }

function extend(target){
  let deep, args = slice.call(arguments, 1)
  if (typeof target == 'boolean') {
    deep = target
    target = args.shift()
  }
  args.forEach(function(arg){ extended(target, arg, deep) })
  return target
}
function extended(target, source, deep) {
    for (let key in source)
      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
        if (isPlainObject(source[key]) && !isPlainObject(target[key]))
          target[key] = {}
        if (isArray(source[key]) && !isArray(target[key]))
          target[key] = []
        extend(target[key], source[key], deep)
      }
      else if (source[key] !== undefined) target[key] = source[key]
}


let fnId = 0,
    eurl = encodeURIComponent,
    doc = document,
    win = window,
    cacheName = 'bridgeFnCache',
    emptyFn = function () {},
    fncache = {};
function processFn(fn,param){
    fnId++;
    var fnname  = param.cbcache ? param.cbcache + '1' : (cacheName + fnId),
        fntype = typeof fn;
    if(fntype === "function"){
        fncache[fnname] = fn;
    }else if(fntype === 'string'){
        var fnarr = fn.split('.'),
            fnnames;
        for (var i = 0; i < fnarr.length; i++) {
            if(i === 0){
                fnnames = window[fnarr[i]];
            }else if(Object.prototype.toString.call(fnnames) === "[object Object]"){
                fnnames = fnnames[fnarr[i]]
            }else{
                fnnames = false;
                break;
            }
            if(!fnnames){
                break;		
            }
        };
        fncache[fnname] =  typeof fnnames === 'function' ? fnnames : emptyFn;
    }//arguments

    if (param.cbcache) {
        return [param.cbcache, '1']
    } else {
        return [cacheName, fnId];
    }
}
// function loadURL(url) {  
//     let iframe = doc.createElement("iframe");
//     iframe.style.display = "none";
//     iframe.src = url;
//     let cont = doc.body || doc.documentElement;
//     cont.appendChild(iframe);

//     setTimeout(function(){
//         iframe.parentNode.removeChild(iframe);
//         iframe = null;
//     }, 200);
// }
// function getEasyJsUrl(obj, functionName, args) {
//     let argStr =  ":s" + eurl(':'+ eurl(args));
//     loadURL("easy-js:" + obj + ":" + eurl(functionName + ":") + argStr);
// }


const ua = navigator.userAgent.toLowerCase();
let bridge = {
    // nuKey : "bridgeFnNewurl2Callback",
    isArray,
    guid,
    isFunction,
    isObject:isPlainObject,
    extend,
    init (){
        bridge = { ...this.getUA(),...bridge, appver:this.getAppVersion()}
    },
    cacheName (a,b){ //设置缓存名称
        return a +'_cbcachemark_' + b;
    },
    getAppVersion (){  // 获取app 版本
        return (function(){
            var verInt = 0,
                verMatch = ua.match(/tctravel\/([\d\.]+)/i);
            if(!!verMatch && verMatch.length >= 2){
                var verStr = verMatch[1].split(".");
                if (verStr.length == 2) {
                    verStr.push(0);
                }
                if (verStr.length == 3){  //
                    verInt = parseInt(verStr.join(""));
                }
            }
            return verInt
        })();
    },
    isAppVersionGreatThan (minVer){ //比较当前版本是否支持 使用的混合api支持版本
        return bridge.appver >= minVer && minVer > 0;
    },
    getUA (){ //获取当前环境 UA (tc  wx  sq touch pc) system : 1：iPhone 2：安卓
        let system,platform;
        if(!ua.match(/ipad|iphone|android|blackberry|windows phone|webos/i)){
            system = 3 // pc
        }else{
            if (ua.indexOf('iphone') > -1 || ua.indexOf('ipad') > -1) {
                system = 1;// iPhone
            }else if (ua.indexOf('android') > -1) {
                system = 2;// Android
            }else {
                system = 4 //windows phone  + other
            }
        }
        if (ua.indexOf("tctravel") != -1) {
            platform = 'tc';
        }else if (ua.indexOf("micromessenger") != -1) {
            platform = 'wx';
        }else if (ua.indexOf("qq/") != -1) {
            platform = 'sq';
        }else{
            platform = system !== 3 ? 'touch':'pc';
        }
        return {
            system:system,platform:platform
        }
    },
    createParam (param){ //构建底层支持的回调函数
        let fnarr = processFn(param.callback,param);
        param.CBPluginName = fnarr[0]
        param.CBTagName = fnarr[1];
        param.param = param.param || {};

        if(param && param.param && param.param.reqbody){
            let data = JSON.stringify(param.param.reqbody);
            param.param.reqbody = data.substring(1, data.length - 1)
        }
        return {
            ...param,
            version:param.version,
        };
    },
    // sendAction (param,dfn,cfn){  //调用客户端bridge方法
    //     if(!param){return}
    //     param = this.createParam(param);
        
    //     if(this.versionContrast(param.version,param.av)){
    //         // param = {
    //         //     param:param.param,
    //         //     CBPluginName:param.CBPluginName,
    //         //     CBTagName:param.CBTagName
    //         // }
    //         try{
    //             delete param.callback;
    //             delete param.version;
    //         }catch(e){}
    //         if(bridge.system == 1){
    //             getEasyJsUrl(dfn, cfn, this.stringifyAndEncode(param));
    //         }else if(bridge.system == 2){
    //             var sendStr = this.stringifyAndEncode(param,(param.uncode && this.isAppVersionGreatThan(param.uncode)));
    //             win[dfn] && win[dfn][cfn] && win[dfn][cfn](sendStr);
    //         }
    //     }
    // },
    // versionContrast (v,av){ //获取版本比较是否支持（存在api 在安卓和ios 中 支持的版本不同）
    //     let ver = this.system == 2 && av ? av : v;
    //     return this.isAppVersionGreatThan(ver);
    // },
    stringifyAndEncode (jsonObj,notcode) { //json转字符串 + 编码
        try{
            let val = JSON.stringify(jsonObj);
            if(!notcode){
                val = encodeURIComponent(val)
            }
            return val;
        }catch(e){
            return '';
        }
    },
    decodeAndParse (jsonStr) { //解码+json 格式化
        try{
            return JSON.parse(decodeURIComponent(jsonStr))
        }catch(e){
            return {};
        }
    },
    // registerFn(p,config,dfn){  //注册方法
    //     for(let item in config){
    //         const vals = config[item],
    //             name = vals.n,
    //             ep = vals.ep;
    //         p[item] = function (param){
    //             if(!param && !ep){
    //                 return;
    //             }
    //             if(bridge.platform == 'tc'){ //非客户端环境不执行
    //                     let callback = param.callback;
    //                     try{delete param.callback}catch(e){}
    //                     bridge.sendAction({
    //                         param:{
    //                             ...param
    //                         },
    //                         cbcache:vals.cbcache,
    //                         uncode:vals.uncode,
    //                         callback,
    //                         version:vals.v,
    //                         av:vals.av
    //                     },dfn,name);
    //                         //reject(error);
    //             }else{
    //                 throw new Error('not in tctravel app')
    //             }
    //         }
    //     }
    // },
    buildCBData:function(data){
        return {
            CBData: typeof data === 'string' ? data : this.stringifyAndEncode(data,true)
        }
    },
    isObjectValueEqual
}

function isObjectValueEqual(a, b) {
    
    let aProps = Object.getOwnPropertyNames(a),
        bProps = Object.getOwnPropertyNames(b);
 
    if (aProps.length != bProps.length) {
        return false;
    }
    for (var i = 0; i < aProps.length; i++) {
        var propName = aProps[i],
            list1 = a[propName],
            list2 = b[propName];
        if(isObject(list1)){
            if(!isObject(list2)){return false}
            if(!isObjectValueEqual(list1,list2)){
                return false;
            }
        }else if(isArray(list1)){
            if(!isArray(list2)){return false}
            if(isArrayValueEqual(list1,list2) === false){
                return false;
            }
        }
        if (list1 !== list2) {
            return false;
        }
    }
    return true;
}
function isArrayValueEqual(a,b){
    if(a.length !== b.length){
        return false;
    }
    //a.every 兼容如何？ 
    for(let i = 0;i < a.length; i++){
        let list1 = a[i],
            list2 = b[i]
        if(isObject(list1)){
            if(!isObject(list2)){return false}
            if(!isObjectValueEqual(list1,list2)){
                return false;
            }
        }else if(isArray(list1)){
            if(!isArray(list2)){return false}
            if(isArrayValueEqual(list1,list2) === false){
                return false;
            }
        }else if(b[i] !== a[i]){
            return false
        }
    }
}

bridge.init()

window._tc_bridge_public = window._tc_bridge_public  || {}; 
//cookie
;(function () {
    var pluses = /\+/g;

    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }

    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }

        try {
            // Replace server-side written pluses with spaces.
            // If we can't decode the cookie, ignore it, it's unusable.
            // If we can't parse the cookie, ignore it, it's unusable.
            s = decodeURIComponent(s.replace(pluses, ' '));
            return config.json ? JSON.parse(s) : s;
        } catch (e) {
        }
    }

    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return isFunction(converter) ? converter(value) : value;
    }

    var config = bridge.cookie = function (key, value, options) {

        // Write

        if (value !== undefined && !isFunction(value)) {
            options = {...config.defaults, ...options};

            if (typeof options.expires === 'number') {
                var days = options.expires,
                    t = options.expires = new Date();
                t.setTime(+t + days * 864e+5);
            }

            return (document.cookie = [
                encode(key), '=', stringifyCookieValue(value),
                options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                options.path ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }

        // Read

        var result = key ? undefined : {};

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all. Also prevents odd result when
        // calling cookie().
        var cookies = document.cookie ? document.cookie.split('; ') : [];

        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            var name = decode(parts.shift());
            var cookie = parts.join('=');

            if (key && key === name) {
                // If second argument (value) is a function it's a converter...
                result = read(cookie, value);
                break;
            }

            // Prevent storing a cookie that we couldn't decode.
            if (!key && (cookie = read(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }

        return result;
    };

    config.defaults = {};

    bridge.removeCookie = function (key, options) {
        if (bridge.cookie(key) === undefined) {
            return false;
        }

        // Must not alter options, thus extending a fresh object...
        bridge.cookie(key, '', {...options, ...{expires: -1} } );
        return !bridge.cookie(key);
    };
})();

//localHelper

let localHelper = {
    get: function(name) {
        if (!name) {
            return '';
        }
        var vals = '';
        try {
            vals = localStorage.getItem(name)
            if (vals === null) {
                vals = bridge.cookie(name)
            }
        } catch (e) {
            vals = bridge.cookie(name)
        }
        vals = vals || '';
        return decodeURIComponent(vals);
    },
    set: function(name, value) {
        if (!name || (!value && value !== 0)) {
            return;
        }
        try {
            localStorage.setItem(name, encodeURIComponent(value))
        } catch (e) {
            bridge.cookie(name, value, { path: '/', expires: 300 })
        }
    },
    remove: function(name) {
        try {
            localStorage.removeItem(name)
        } catch (e) {
            bridge.removeCookie(name, { path: '/' })
        }
    }
};
bridge.localHelper = localHelper;
 
export default bridge;