
let pos = {  //记录状态
    start : 1,
    stopMove:true
},
timers;
function constrain(val, min, max) {
    return Math.max(min, Math.min(val, max));
}
function scroll (val, time, fn){
    let mh = constrain(val,pos.mins,pos.maxs),
        times = time ? time.toFixed(3) : 0;
    this.ulStyle = {
			transition: `all ${times}s ease-out`,
			transform: `translate3d(0,${mh}px,0)`
        }
    pos.start = this.moveHeight = mh;
  
    timers && clearTimeout(timers)
    timers = setTimeout(function () {
        
        fn && fn();
    }, (time || 0) * 1000);
}
let startTime;
export default {
    
    ListTouchStart (e){
        let { moveHeight, mins, maxs } = this;
        if (e.targetTouches && e.targetTouches.length == 1) {
            let touch = e.targetTouches[0];
            pos.startTop = touch.pageY;
            pos.start = moveHeight;
            pos.stopMove = false;
        }else{
            pos.stopMove = true;
        }
        pos.mins = mins;
        pos.maxs = maxs;
        startTime = new Date();
        pos._start = pos.start;

    },
    ListlTouchMove (e){
        let { moveHeight, mins, maxs } = this;
        
        if(pos.stopMove){return}

        if (e.targetTouches.length == 1) {
            let touch = e.targetTouches[0];
            pos.moveTop = touch.pageY;
            pos.lastMove = pos.moveTop - (pos.lastTop || pos.startTop) + pos.start;
            scroll.call(this,pos.lastMove,0);
            pos.lastTop = pos.moveTop;
        }
    },
    ListTouchEnd (e,changeFn){
        let timediff = new Date() - startTime,
            lastTop = pos.lastMove,
            { lhi, larger } = this,
            start = pos._start || pos.start, //touchstart 的时候 位置 用来计算移动的位移距离
            dist,  //位移距离
            speed; //速度
        if (timediff < 300) { //300
            
            speed = Math.abs(Math.abs(lastTop) - Math.abs(start)) / timediff;
            dist = (speed * speed) / 0.0013 //s.speedUnit;
            timediff = Math.sqrt(Math.abs(speed * speed * 0.8)) * 8 / 10;
            if (pos.moveTop < pos.startTop) {
                dist = -dist;
                
            }
            lastTop = lastTop + dist;
        } else {
            timediff = 0.01;
        } 
        lastTop = constrain((Math.round(parseFloat(lastTop,10) / lhi) * lhi), pos.mins, pos.maxs);
        scroll.call(this, lastTop, timediff,function(){
            changeFn( Math.abs( (lastTop / lhi) - (larger ?  3 : 2) ) )
        //    that.selectChange( Math.abs( (lastTop / lhi) - (larger ?  3 : 2) ) )
        })
        pos.lastTop = 0;
    }
}