

var requestId = Math.floor(Math.random() * 1000000000000),
    // OBJECT_PROTO = Object.prototype,
    requestCache = {};

function isNotEmptyString (str) {
    return typeof str === "string" && str !== "";
}
// function isPlainObject(v) {
//     return Object.getPrototypeOf(v) === OBJECT_PROTO;
// }
// function getFuncName (fn) {
//     return typeof fn.name === "string" ? fn.name : (/function\s*([^\(\s)]*)/.test(fn.toString()), RegExp["$1"]);
// }

// 最简单的参数处理，为什么只提供简单的参数处理
function param(data) {
    var strs = [];
    for (var name in data) {
        strs.push(name + "=" + encodeURIComponent(data[name]));
    }
    return strs.join("&");
}

function getScript (url, callback, realTime) {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.async = true;
    if (typeof callback === "function") {
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                callback();
            }
        };
    } else {
        realTime = callback;
    }
    script.src = url + (realTime ? ((/\?/.test(url) ? "&" : "?") + "_=" + (requestId++)) : "");
    document.getElementsByTagName("script")[0].parentNode.appendChild(script);
    return script;
}

 /**
    * jsonp(url, callback);
    * jsonp(url, callback, options)
    * jsonp(url, data, callback);
    * jsonp(url, options)
    * options = {
    *     callback
    *     cache 要使用jsonp的缓存功能，和错误处理功能，都不能配置jsonpCallback
    *     error
    *     jsonp
    *     jsonpCallback // 配置了回调函数名，错误处理机制将失效，同时传递了callback和jsonpCallback，如果重写原有的函数是很危险的，callback传入的是函数变量或者对象方法，才需要传入jsonCallback
    *     
    *     如果需要使用使用缓存或者错误处理的功能，需要callback的函数名不等于jsonpCallback设置的函数名
    *     如果只设置了jsonpCallback而没有设置callback将不能使用缓存和错误处理功能
    *     
    *     // 这个参数我想不提供，为了简化接口
    *     // 匿名函数提供这个参数反而会出问题，唯一有用的是callback是对象的一个方法，需要通过对象方法函数的形式调用，同时不需要缓存和错误处理
    *        即便是这种情况，还是可以通过其他方式解决
    *     
    Foo () {
        
    }
    var Foo.prototype.a = function(data) {
            
    }
    var bar = new Foo();
    bar.a作为callback值传递给jsonp函数，并且希望通过bar.a(data)方式执行
    利用闭包做进一步包装就好，可以满足上面的出现的情况，并且可选的使用缓存和错误处理
    functioncallback(data) {
    bar.a(data);
    }
    *     一开始决定提供这个参数是因为jQuery和kissy都提供了这个参数
    *     timeout: 16s
    * }
    **/
function jsonp (url, option) {
    return new Promise(function(resolve, reject){
            // var callback;
            // if (typeof data === "function") {
            //     callback = data;
            //     data = (option && option.data) || "";
            // } else if (typeof option === "function") {
            //     callback = option;
            //     option = undefined;
            // } else {
                // option = data;
                // callback = option.callback;
                // data = option.data || "";
            // }
            option = option || {};
            var data = option.data || "";
            data = typeof data === "string" ? data : param(data);
            var connector = /\?/.test(url) ? "&" : "?";
            if(data){
                url += connector + data;
            }
            var cache = option.cache,// === undefined ? true : option.cache,
                cacheContent;
            if (cache && (cacheContent = requestCache[url])) {
                // cacheContent[0](cacheContent[1]);
                resolve(acheContent[1])
                return;
            }
            if (data) {
                connector = "&";
            }
            if(option.type != 'script'){
                var jsonpCallback = option.jsonpCallback,
                    aborted = false,
                    timer;
                if (!isNotEmptyString(jsonpCallback)) {
                    jsonpCallback = "jsonp" + (requestId++);
                }
                // if (callback && jsonpCallback !== getFuncName(callback)) {
                window[jsonpCallback] = function (data) {
                    if (aborted) {
                        return;
                    }
                    // callback(data);
                    resolve(data);
                    if (option.cache) {
                        requestCache[url] = [jsonpCallback, data];
                    }
                    clearTimeout(timer);
                };
            }
            
            // if (option.error) {
                timer = setTimeout(function () {
                    aborted = true;
                    // option.error();
                    reject()
                }, option.timeout ? option.timeout : 10000); // 默认10s 超时 失败
            // }
            // }
            var finalUrl = url + connector + (option.jsonp ? option.jsonp : "callback") + "=" + jsonpCallback;
            getScript(finalUrl , (option.type === "script" ? resolve : false));
    })
}

export default jsonp;